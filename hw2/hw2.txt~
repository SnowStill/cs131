(* Problem 7 *)
The reason I decided to use make_parser in terms of make_matcher is that they work in a very similar way in iteration. Since make_matcher is searching the terminal terms in a order of tracking down a tree, then why can't I just apply the make_matcher algorithm with a little bit modification to the make_parser algorithm. 
By saying that, The major thing I changed is that instead of returning the reamaing parse, I return the path that I've been tracking down to the place where I found the terminal term that is matched parse. The way they iterate the rules list are the same; the way they iterate the parse are the saem; even the check condition are the same. The only thing that is  different is that I mofified the acceptor function and the helper functions for make_parser when they get passed recursively. For the acceptor function in make_matcher, it only carries the rest rules list so it can finish tracing down the combination before it returns something from the next subtree. But for the make_matcher, I need to track down the path, so I had to let the shifeted_acceptor function to carry the path, which is appending the path recursively. 
The Problem is that, if we look at the testcase2 and 3 for make_matcher, it only can detect the grammer from the beginning. If the first two terms are valid and the last 2 are not, it will return the last 2 terms as unmatched. However, if the first teo terms are invalid and the last 2 are valid, it wil just return none. Also I tried out some stupid thing that makes my program runs in an infinite loop by having a grammer that contains itself. In this case, my program would just run down to that specific catagory over and over again. I assume that the grammer should not have a nonterminal that incluse itself. 
Some problem I have encounterd: I had a big trouble to write out the two helper functions for make matcher. These two functions are requied, and they are calling each other, which implies that if I declare one of them first, it will not be able to call another one since it has been difined afrter the first one. Until I know that by using "and," you can make two functions to call each other. That makes my life much easier. Also I had a hard time to do the append path based on recursion. In my opinion, thinking recursively is just quite hard and tedious.
